import bpy

import os

from typing import List
from typing import Optional

# This is a set of tools to procedurally edit characters generated by Manuel Bastioni Lab.
# All operators are under name space "object.mbast_tools" (the original MBLab operators are under mbast)

#
# Maps the name of the Mesh to the names of the diffuse and displacement images
TEXTURE_IMAGE_MAP = [
    ('MBLab_human_female', 'human_female_diffuse.png', 'human_female_displacement.png'),
    ('MBLab_human_male', 'human_male_diffuse.png', 'human_male_displacement.png'),
]

R_HAND_NAME = "hand_R"
L_HAND_NAME = "hand_L"

# The animation containing the pose with the relaxed fingers
RELAXED_FINGER_ANIM = "relaxed_fingers_anim.json"


#
# Phenotype tests
def is_female(mesh_obj: bpy.types.Object) -> bool:
    mesh = mesh_obj.data  # type: bpy.types.Mesh
    return mesh.name.startswith('MBLab_human_female')


def is_male(mesh_obj: bpy.types.Object) -> bool:
    mesh = mesh_obj.data  # type: bpy.types.Mesh
    return mesh.name.startswith('MBLab_human_male')


def is_mblab_body(mesh_obj: bpy.types.Object) -> bool:
    mesh = mesh_obj.data  # type: bpy.types.Mesh
    return mesh.name.startswith('MBLab_')


# TODO -- Find a way to discriminate between finalized and not finalized characters
# def is_finalized_mblab_body(mesh_obj: bpy.types.Object) -> bool:
#     if not is_mblab_body(mesh_obj=mesh_obj):
#         return False
#
#     if hasattr(mesh_obj, 'Body_Size'):
#         return False
#
#     return True


def character_prefix(mesh_obj: bpy.types.Object) -> Optional[str]:
    """Get the prefix that has been used to create the character.
    :param mesh_obj: The MESH object, as created and named by MBLab.
    """

    import re

    patt = re.compile("^(.+)_body$")
    res = patt.match(mesh_obj.name)
    if res:
        name = res.group(1)
        return name
    else:
        return None


#
#
# Material Fixing
class FixMaterials(bpy.types.Operator):
    """Fix the materials of the Manuel Bastioni Lab characters to be compatible and ready for real-time rendering
    with the Blender Game Engine"""
    bl_idname = "mbast_tools.fix_materials"
    bl_label = "MBLabTools Fix Materials"

    @classmethod
    def poll(cls, context):
        obj = context.active_object
        if obj is not None:
            if obj.type == 'MESH':
                return True

        return False

    def execute(self, context):

        from mathutils import Color

        mesh_obj = context.active_object  # type: bpy.types.Object
        mesh = mesh_obj.data  # type: bpy.types.Mesh

        char_name = character_prefix(mesh_obj=mesh_obj)
        if char_name is None:
            self.report({'ERROR'}, "Character not properly named (should be, for example: 'Anna_body')")
            return {'CANCELLED'}

        diffuse_texture_name, displacement_texture_name = None, None
        for map_entry in TEXTURE_IMAGE_MAP:
            if mesh.name.startswith(map_entry[0]):
                diffuse_texture_name, displacement_texture_name = map_entry[1:3]

        if diffuse_texture_name is None:
            self.report({'ERROR'}, "Unsupported Mesh type {}".format(mesh.name))
            return {'CANCELLED'}

        # Check if the diffuse and displacement textures still exist.
        # They disappear if the user save and quit blender and reload the character.
        if diffuse_texture_name not in bpy.data.images:
            self.report({'ERROR'}, "Can not find a texture named '{}'."
                                   " Maybe the scene was saved after finalization and then reloaded?"
                        .format(diffuse_texture_name))
            return {'CANCELLED'}

        if displacement_texture_name not in bpy.data.images:
            self.report({'ERROR'}, "Can not find a texture named '{}'."
                                   " Maybe the scene was saved after finalization and then reloaded?"
                        .format(displacement_texture_name))
            return {'CANCELLED'}

        #
        # Now, some magic creating nice real-time materials for Blender Game Engine and the rest
        # of the world, too.

        # print("# materials: {}".format(len(mesh.materials)))
        for mat in mesh.materials:
            # print(mat.name)
            mat.use_nodes = False
            mat.use_transparency = False
            # mat.game_settings.physics = False

        diffuse_tex = bpy.data.textures.new('MBLabDiffuse', 'IMAGE')
        diffuse_tex.image = bpy.data.images[diffuse_texture_name]
        diffuse_tex.image.use_fake_user = True
        diffuse_tex.image.use_alpha = False  # This texture has not alpha channel. Pixels are all at 255.

        disp_tex = bpy.data.textures.new('MBLabDisp', 'IMAGE')
        disp_tex.image = bpy.data.images[displacement_texture_name]
        disp_tex.image.use_fake_user = True

        # materials: 7
        # MBlab_pupil
        # MBlab_generic
        # MBlab_cornea
        # MBlab_fur
        # MBlab_human_skin1501659564.030342
        # MBlab_human_eyes1501659564.030366
        # MBlab_human_teeth1501659564.03038

        for mat in mesh.materials:  # type: bpy.types.Material
            # For most materials, set the texture slot 0 to use the diffuse texture

            if mat.name.startswith(char_name+"_MBlab_pupil"):
                mat.texture_slots.create(0)
                mat.texture_slots[0].texture = diffuse_tex
                mat.diffuse_color = Color((0.0, 0.0, 0.0))
            elif mat.name.startswith(char_name+"_MBlab_generic"):
                pass
            elif mat.name.startswith(char_name+"_MBlab_cornea"):
                mat.use_transparency = True
                mat.alpha = 0.1
            elif mat.name.startswith(char_name+"_MBlab_fur"):
                mat.diffuse_color = Color((0.013, 0.013, 0.013))
                mat.specular_color = Color((0.0, 0.0, 0.0))

                mat.use_transparency = True
                mat.transparency_method = 'Z_TRANSPARENCY'
                mat.alpha = 0.0
                # Fix the way the texture is interpreted for the eyeleashes
                # The default texture has only color info. We must use RGB info as transparency:
                # Black=opaque, white=transparent
                mat.texture_slots.create(0)
                mat.texture_slots[0].texture = diffuse_tex
                mat.texture_slots[0].use_map_alpha = True
                mat.texture_slots[0].use_map_color_diffuse = False
                mat.texture_slots[0].invert = True
            elif mat.name.startswith(char_name+"_MBlab_human_skin"):
                mat.specular_intensity = 0.2
                mat.texture_slots.create(0)
                mat.texture_slots[0].texture = diffuse_tex
                mat.texture_slots.create(1)
                # For the skin only, set the slot 1 to use displacement
                mat.texture_slots[1].texture = disp_tex
                mat.texture_slots[1].use_map_color_diffuse = False
                mat.texture_slots[1].use_map_normal = True
                mat.texture_slots[1].normal_factor = 0.03
            elif mat.name.startswith(char_name+"_MBlab_human_eyes"):
                mat.texture_slots.create(0)
                mat.texture_slots[0].texture = diffuse_tex
            elif mat.name.startswith(char_name+"_MBlab_human_teeth"):
                mat.texture_slots.create(0)
                mat.texture_slots[0].texture = diffuse_tex
            else:
                self.report({'ERROR'}, "Unexpected material named '{}'".format(mat.name))
                return {'CANCELLED'}

        return {'FINISHED'}


#
#
#
class SetupMBLabCharacter(bpy.types.Operator):
    """Setup a ManuelBastioniLab character to be ready for rendering in real-time and exportation to Unity."""
    bl_idname = "mbast_tools.setup_mblab_character"
    bl_label = "MBLab Tools - Setup MBLab Character"

    #
    # DEFINITIONS: SUPPORT FUNCTIONS
    @staticmethod
    def clear_selection(mesh_obj: bpy.types.Object):
        """Make sure that the editor is in the following state:
            * OBJECT_MODE
            * selected: one object, the mesh object.
            * active: the mesh object.
        """

        # Switch to OBJECT mode
        bpy.ops.object.mode_set(mode='OBJECT')

        # Unselect everything
        for o in bpy.context.scene.objects:
            o.select = False

        # The MESH object will be the active and the only selected object
        mesh_obj.select = True
        bpy.context.scene.objects.active = mesh_obj

    @classmethod
    def poll(cls, context):
        obj = context.active_object
        if obj is not None:
            if obj.type == 'MESH':
                return True

        return False

    def execute(self, context):
        from yallah import YALLAH_FEATURES_DIR

        mesh_obj = bpy.context.active_object
        assert mesh_obj.type == 'MESH'

        arm_obj = mesh_obj.parent
        if arm_obj is None:
            self.report({'ERROR'}, "Character Mesh must have a parent Armature")
            return {'CANCELLED'}

        if arm_obj.type != 'ARMATURE':
            self.report({'ERROR'}, "Character Mesh parent object {} must be Armature".format(arm_obj.name))
            return {'CANCELLED'}

        assert arm_obj.type == 'ARMATURE'

        char_name = character_prefix(mesh_obj=mesh_obj)
        if char_name is None:
            self.report({'ERROR'}, "Character not properly named (should be, for example: 'Anna_body')."
                                   " Please, use the MBLab prefix during finalization.")
            return {'CANCELLED'}


        #
        # A TEST TO CHECK FOR WORKING DIRECTORIES AND PATHS
        # This is harmless and can be used as template to develop new functionalities
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "Test/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        #
        # FIX THE MATERIALS AND MODE FOR REAL-TIME RENDERING (AND UNITY)
        #
        bpy.context.scene.game_settings.material_mode = 'GLSL'
        bpy.context.scene.render.engine = 'BLENDER_GAME'

        # Switch the view to Material mode, so that we can appreciate the fixes to the materials.
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.viewport_shade = 'MATERIAL'

        filepath = os.path.join(YALLAH_FEATURES_DIR, "RealTimeMaterials/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        #
        # CREATE THE VISEMES FOR TTS
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "MaryTTS/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        #
        # CREATE THE Facial Expressions(FE)
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "FacialExpressions/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        #
        # CREATE THE BONES NEEDED FOR EYEGAZE CONTROL
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "EyeGaze/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        SetupMBLabCharacter.clear_selection(mesh_obj=mesh_obj)

        #
        # CREATE THE BONES NEEDED FOR DYNAMIC CAMERA FRAMING
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "Camera/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        SetupMBLabCharacter.clear_selection(mesh_obj=mesh_obj)

        #
        # REMOVE THE SURFACE SUBDIVISION MODIFIER
        #
        # We need to remove this, otherwise the blendshapes will not be visible in Unity
        #
        # n_modifires = len(mesh_obj.modifiers)
        # print("There are {} modifiers".format(n_modifires))
        for md in mesh_obj.modifiers:
            if md.name == "mbastlab_subdvision":
                mesh_obj.modifiers.remove(md)
                break

        #
        # CREATE A REFERENCE A-Pose, with object transform and all bones reset to identity.
        #
        bpy.context.scene.objects.active = arm_obj
        bpy.ops.yallah.create_apose_action()

        SetupMBLabCharacter.clear_selection(mesh_obj=mesh_obj)

        #
        # MARK THE SETUP AS DONE
        #
        mesh_obj.yallah_setup_done = True

        return {'FINISHED'}


#
#
# ANIMATION

def list_bones_recursive(b: bpy.types.PoseBone, include_root: bool = True) -> List[bpy.types.PoseBone]:
    out = []

    if include_root:
        out += [b]

    for child in b.children:
        c = list_bones_recursive(child, include_root=True)
        out = out + c

    return out


class RemoveAnimationFromFingers(bpy.types.Operator):
    """Remove all animation curves from the hands of a MBLab character"""
    bl_idname = "mblab_tools.remove_finger_animation"
    bl_label = "MBLab Tools - Remove animation curves for the fingers from the active action"

    @classmethod
    def poll(cls, context):

        if not (context.mode == 'POSE' or context.mode == 'OBJECT'):
            return False

        obj = context.active_object  # type: bpy.types.Object
        if obj is not None:
            if obj.type == 'ARMATURE':
                anim_data = obj.animation_data
                if anim_data is not None:
                    act = anim_data.action
                    if act is not None:
                        return True

        return False

    def execute(self, context):
        import re

        # Active Armature
        arm_obj = context.active_object  # type: bpy.types.Object

        # Get hand bones
        if R_HAND_NAME not in arm_obj.pose.bones:
            self.report({'ERROR'}, "No bone named '{}' in armature {}".format(R_HAND_NAME, arm_obj.name))
            return {'CANCELLED'}

        if L_HAND_NAME not in arm_obj.pose.bones:
            self.report({'ERROR'}, "No bone named '{}' in armature {}".format(L_HAND_NAME, arm_obj.name))
            return {'CANCELLED'}

        r_hand_bones = list_bones_recursive(b=arm_obj.pose.bones[R_HAND_NAME], include_root=False)
        l_hand_bones = list_bones_recursive(b=arm_obj.pose.bones[L_HAND_NAME], include_root=False)

        # print(r_hand_bones)
        # print(l_hand_bones)

        all_bones = r_hand_bones + l_hand_bones
        bone_names = [b.name for b in all_bones]
        print("Bones ({}):".format(len(bone_names)))
        print(bone_names)

        act = arm_obj.animation_data.action
        print("Removing animations from action clip '{}'".format(act.name))
        print("Number of curves now: {}".format(len(act.fcurves)))

        #
        # Really remove the animation curves
        # All the bone names in a quick-access set.
        bone_name_set = set(bone_names)
        curves_to_remove = []  # type: List[bpy.types.FCurve]
        # Prepare a regular expression to extract the name of the bone from the data_path
        bone_match_re = re.compile('^pose\.bones\["(.+)"\]\..*')
        for fcurve in act.fcurves:  # type: bpy.types.FCurve
            # print("Curve "+fcurve.data_path)

            match_res = bone_match_re.match(fcurve.data_path)
            if match_res is not None:
                data_path_bone = match_res.group(1)
                # print("Matched Bone: " + data_path_bone)

                if data_path_bone in bone_name_set:
                    curves_to_remove.append(fcurve)

        for fc in curves_to_remove:
            # print("Removing" + fc.data_path)
            act.fcurves.remove(fc)

        print("Number of curves after removal: {}".format(len(act.fcurves)))

        return {'FINISHED'}


class SetRelaxedPoseToFingers(bpy.types.Operator):
    """Insert a key frame on the current action to set the finger in relaxed pose."""
    bl_idname = "mblab_tools.set_finger_relaxed"
    bl_label = "MBLab Tools - Insert a key frame on the current action to set the finger in relaxed pose."

    @classmethod
    def poll(cls, context):

        if not (context.mode == 'POSE' or context.mode == 'OBJECT'):
            return False

        obj = context.active_object  # type: bpy.types.Object
        if obj is not None:
            if obj.type == 'ARMATURE':
                anim_data = obj.animation_data
                if anim_data is not None:
                    act = anim_data.action
                    if act is not None:
                        return True

        return False

    def execute(self, context):

        import json
        from mathutils import Quaternion

        from yallah import YALLAH_DATA_DIR

        arm = context.active_object  # type: bpy.types.Object
        assert arm.type == 'ARMATURE'

        with open(os.path.join(YALLAH_DATA_DIR, RELAXED_FINGER_ANIM), 'r') as relaxed_finger_anim_file:
            relaxed_finger_anim = json.load(fp=relaxed_finger_anim_file)

        if type(relaxed_finger_anim) != dict:
            self.report({'ERROR'}, "File '{}' should containt a dictionary at top level".format(RELAXED_FINGER_ANIM))
            return {'CANCELLED'}

        for data_path in relaxed_finger_anim.keys():  # type: str
            if data_path.endswith('rotation_quaternion'):
                quat = arm.path_resolve(data_path)  # type: Quaternion
                data_path_indices = relaxed_finger_anim[data_path]
                # For each of the 4 quaternion components, set its value in the current pose.
                for idx in range(4):
                    data = data_path_indices[str(idx)]
                    kf0 = data[0]
                    # t = kf0[0]  # this is the timestamp
                    v = kf0[1]  # this is the value of the quaternion element
                    # Really set the value for the quaternion
                    quat[idx] = v

                arm.keyframe_insert(data_path=data_path, frame=1, group="fingers")

        return {'FINISHED'}


class ResetCharacterPose(bpy.types.Operator):
    """Reset character main transformations and all pose bones transformations to identity."""
    bl_idname = "mblab_tools.reset_character_pose"
    bl_label = "MBLab Tools - Reset the character pose."

    @classmethod
    def poll(cls, context):

        if not (context.mode == 'POSE' or context.mode == 'OBJECT'):
            return False

        obj = context.active_object  # type: bpy.types.Object
        if obj is not None:
            if obj.type == 'ARMATURE':
                return True

        return False

    def execute(self, context):

        arm_obj = context.active_object  # type: bpy.types.Object
        assert arm_obj.type == 'ARMATURE'

        arm_obj.location = 0, 0, 0
        arm_obj.rotation_quaternion = 1, 0, 0, 0
        arm_obj.rotation_euler = 0, 0, 0
        arm_obj.scale = 1, 1, 1

        for pbone in arm_obj.pose.bones:  # type: bpy.types.PoseBone
            pbone.location = 0, 0, 0
            pbone.rotation_quaternion = 1, 0, 0, 0
            pbone.rotation_euler = 0, 0, 0
            pbone.scale = 1, 1, 1

        return {'FINISHED'}


#
# (UN)REGISTER
#
def register():

    # This property will be use to mark when a character has received the Setup procedure.
    bpy.types.Object.yallah_setup_done =\
        bpy.props.BoolProperty(name="yallah_setup_done",
                               description="When true, the character has already undergone the YALLAH Setup process",
                               default=False)

    bpy.utils.register_class(FixMaterials)
    bpy.utils.register_class(SetupMBLabCharacter)
    bpy.utils.register_class(RemoveAnimationFromFingers)
    bpy.utils.register_class(SetRelaxedPoseToFingers)
    bpy.utils.register_class(ResetCharacterPose)


def unregister():
    bpy.utils.unregister_class(FixMaterials)
    bpy.utils.unregister_class(SetupMBLabCharacter)
    bpy.utils.unregister_class(RemoveAnimationFromFingers)
    bpy.utils.unregister_class(SetRelaxedPoseToFingers)
    bpy.utils.unregister_class(ResetCharacterPose)

    del bpy.types.Object.yallah_setup_done


if __name__ == "__main__":
    register()
