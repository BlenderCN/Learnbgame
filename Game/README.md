# [Game Engine]()

# 基础架构

###  游戏引擎的分层架构
##### 工具层
##### 为什么要分层
*  减少耦合，降低复杂度
*  上层无需知道下层的具体实现
*  应对不同的需求变化
##### 功能层
*  GameTick控制各系统周期性更新
*  为游戏引擎提供核心功能模块
*  多核多线程架构趋势
##### 资源层
*  GUID
*  运行时资产管理
    1.  虚拟文件系统
    2.  Handle
*  资产生命周期
    1.    不同资源有不同的生命周期
    2.    尽可能减少资源的内存申请与释放
    3.    垃圾回收
   
##### 平台层
*    硬件架构
*    图形API概念
##### 核心层
*    数学计算库
*    数据结构与容器
*    内存管理


###  如何构建游戏世界
##### 游戏世界组成
*    万物皆Game Object
*    动态物
*    静态物
*    环境
*    其他
##### GameObject组成
*    组件
*    继承
##### 复杂情况处理
*    组件间的依赖关系
*    Game Object间的依赖关系
*    事件的处理时机
##### 游戏场景管理
*    空间数据结构
*    Game Object检索
##### 如何让游戏世界动起来
*    基于对象的更新Object-based tick
*    基于组件的更新Commponent-base tick
*    事件机制（基本概念）


# 渲染

### GPU渲染管线
*    顶点着色器
*    几何着色器
*    光栅化
*    像素着色器
*    合并阶段
### GPU架构
*    Immediate Mode Rendering
*    Tile Base Rendering
*    Tile Based Deferred Rendering
### 可见性裁剪
*    视锥裁剪
*    Potential Visibililty Set
*    遮挡剔除
*    入口裁剪

### 场景空间管理
*    层次包围盒（BVH）
*    二元空间分割树（BSP Trees）
*    四叉树（Quad Tree）
*    八叉树（Octree）
*    场景图（Scene Graphs）
*    KD树（K-Dimensional Tree）
### 贴图压缩

##### Adaptive Scalable Texture Compression
##### Ericsson Texture Compression
##### Block Compression
##### 为什么不使用png和jpg等常见压缩格式
尽管像jpg、png的压缩率很高，但并不适合纹理，主要问题是不支持像素的随机访问，这对GPU相当不友好，GPU渲染时只使用需要的纹理部分。
##### 为什么我们需要纹理压缩格式
*    内存
*    带宽
##### 压缩纹理算法特点
*    解压速度
*    随机访问
*    压缩率和图像质量
*    编码速度

### Frame Graph
##### 目标
*    单一实现，与图形API无关
*    简化渲染管线配置
*    简化异步渲染和资源屏障
*    支持多GPU渲染，可指定调度策略

##### 流程
*    Setup
            在这个阶段并不产生任何GPU命令，所有的资源都是虚拟的
*    Compile
*    1.    剔除所有没有被引用的Resources和Passes
     2.    计算资源的生命周期
     3.    根据资源的用途创建实际的GPU资源
*    Execute
            简单地顺序遍历所有真正需要绘制的Pass
 


### 渲染系统
##### 光照
*    全局光照
*    1.    光照探灯
     2.    反射探灯
     3.    预计算光照数据
*    IBL
*    1.    Specular
               Pre-filtered Environment Map
               Brdf Lut
       
     3.    Diffuse
               Irradiance Map
*    BRDF模型
*    1.    Lambert模型
     2.    Phong模型
     3.    Blinn-Phong模型
     4.    Cook-Torrance模型

##### 后处理

*    颜色校正

*    抗锯齿
*    1.    超级采样抗锯齿
            优点：往往能得到最佳的效果
            缺点：它会带来巨大的性能消耗
     3.    多重采样抗锯齿
            图像保真度和性能之间找到最佳的平衡点
     4.    快速近似抗锯齿
            优点：是低端PC最佳的抗锯齿方案，它对GPU的要求不是很高，因为它直接平滑屏幕图像而不需要考虑到游戏中的3D模型
            缺点：边缘和纹理会变得有点模糊
     6.    时间性抗锯齿
            综合历史帧的数据来实现抗锯齿，这样会将每个像素点的多次采样均摊到多个帧中，相对的开销要小得多

##### 基于物理渲染
*    能量守恒
           出射光线的能量，永远不能大于入射光线的能量
*    基于物理相机
*    1.    快门速度
            产生运动模糊效果
*    2.    光圈
            产生景深效果
*    3.    感光度
            产生Grain效果
*    基于物理材质
*    1.    SG工作流
           Albedo Color
           Specular Color
           Glossiness
           Normal
           优点：可以自己控制非金属F0值
           缺点：F0可能用错从而导致破坏PBR原则，因为工作流程有些名词和传统的工作流太相似，但实际对应的数据可能是不一样的。RGB贴图多，占用内存多。
*    2.    基于物理相机
           快门速度：产生运动模糊效果
           光圈：产生景深效果
           感光度：产生Grain效果
*    3.
##### 视效
##### 环境光遮蔽
##### 大气
##### 雾效
##### 云
##### 渲染管线
##### 地形
##### 阴影



### Nanite
### Lumen





# 动画系统

### 动画技术基础
### 动画技术进阶

# 物理系统

### 物理系统基础概念
### 物理系统应用

# 音效

### 音频
### 声音基础

# GamePlay

### 复杂的游戏性及其基本要素
### 基础AI系统
### 构建高级的AI系统

# 工具链

### 界面（GUI)
### 资产管理
### 数据结构设计
### C++代码反射
### 鲁棒性设计
### 软件架构
### 常见编辑器
### 插件
### 协同编辑



# 网络

### 网络基础
### 网络同步
### 服务器架构
### 游戏优化

# 面向数据编程与任务系统

### 游戏并行框架
### 实体-组件-系统ECS
### 面向数据编程
### 并行编程基础知识
